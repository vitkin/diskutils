#!/bin/bash
#
# confinedrv v1.2.1
# (c) copyright by Elmar Stellnberger, the original author: 2009, Jan 2010
#
#  further information: www.elstel.org/com; look here for an actual contact address
#  current email: estellnb@elstel.org; additional email estellnb@gmail.com
#
# v 1.7.1: small fixups (16.11.2014)
#  * a problem in theory: eliminated race condition dropping loop devices, cleanup by --freeloop after kill -9
#  * writable loop device only allocated if needed (previously: if any even non writable partition was specified)
#  * acc2str -> access table printing: make a difference between zero and error
#  * skip function is now more thoroughly documented
#
# v 1.7: fixing some boot issues and providing enhanced functionality
#  * Certain boot problems which have arised under respective circumstances with v1.2.1 due to err-ing out gap spaces needed by grub or 
#    other loaders rather than zeroing them out or making them available as read-only should now be resolved.
#  * choose for any of three modes for every partition: read, write, error or zero (sdx=sda:r1:e2,3:w5,6,7:z8); default is now to zero
#    out any parition which has not been mentioned rather than letting any access err there.
#  * The --gap and --mbr options provide means for specifying the access rights for gaps between primary partitions or all the space
#    before the first partition including the partition table and the MBR respectively.
#  * The [--noannot] --info sdx now provides a better readable map of the partition table annotated with symbolic references for the
#    start and end of partitions by default. --loopusage shows all loop devices in use by confinedrv.
#
# v 1.2.1: small fix (17.11.2013)
#  * correctly allocate/deallocate loop drives if more than one virtual drive is specified on the command line
#
# v 1.2: new algorithm (17.11.2013)
#  * completely reworked and better algorithm
#
# v 1.1: added license (30.10.2013)
#  * better option parsing; some minor fixes
#  * reads page size by getconf
#
# v.1.0: originally published version (Jan 2010)
#  * original authors: Elmar Stellnberger
#

license() {
  echo -e "\e[1mThis program may be used under the terms of C-FSL v1.0:\e[0m"; echo
  cat <<EOQ
CONVERTIBLE FREE SOFTWARE LICENSE
	Version 1.0, 2016-08-10
copyright 2016, by Elmar Stellnberger
Everyone is permitted to copy and distribute verbatim copies of this license document. You must not modify the license itself.
This license applies to any software containing a notice by the copyright holder saying that it may be used under the terms of the Convertible Free Software License. If a specific version number is mentioned then usage rights include this version as well as any newer version which will always be similar in spirit to this license. The term Convertible Free Software license may be abbreviated as C-FSL.

1. Any work under this license comes completely without any warranty or any kind of liability such as lost revenues, profits, harm or damage of any kind even if the authors should have been advised of the possibility of such harm or damage. It may be seen as research work and does not claim for fitness to any particular usage purpose.

2. The term 'source code' applies to the preferred form that is used to develop or apply changes to a work under this license referred to herein as 'the work'. You are allowed to modify or change the source code if you accept that the resulting changed work will become subject to this license. As soon as you apply any change this is an implicit consent to fully comply with this license and a consent that the work may be used under this license. 

3. It is your obligation that the changed version of your sources will be available to the public for free within the time frame of a month at least if there is no undue hindrance by the authors to make it available. Modifications which result in a broken or unusable program which the authors do not plan to continue their work on are considered dead end and do not need to be published. Available for free means that there will be no undue hindrance in obtaining the given item like a registration of the person who wants to download or obtain the given item. Available for free also means that you must not charge for the given item itself apart from the possibility to require a reasonable charge for the physical reproduction of the data.

4. You are allowed to issue an 'automatic derivation process' on the source code which will result in so called 'object code'. You are obligated to provide sufficient data, tools and utilities so that a functionally equivalent object code can be compiled merely from programs and work licensed either under any open source license approved by opensource.org or under C-FSL. The given data and utilities for obtaining functionally equivalent results need to be available to the public for free.

5. When applying changes to the source code you need to leave your name, your email address and the date of your modifications so that other people may contact you. If a contributor should not have a steady access to the internet or a satisfying access to an emailing service he may leave another way by which he can be contacted. We suggest to list all changes by contributors either in a separate changelog file or in the header of the changed file. Several consecutive changes may be collapsed. Furthermore you need to give your changed version a 'marker' which may be used to distinguish it from the upstream version when being distributed to other people. The distributed product needs to be of the form upstream name - dash upstream version - dash your marker optionally followed by a version number under your control. If there should be a chain of upstream contributors there only needs to be one marker by the party which is at the end of the chain as long as that chain remains to be documented in some place where it is shipped with your software. The marker needs to be unique, at least two letters in size. We suggest it to reflect the name of your company or distribution.

6. You may choose to create a fork of a work under C-FSL by giving it a completely different name. However you need to assert that people will know that your fork is based on the original work. If your program has a graphical user interface the whole C-FSL license must be referenced via the GUI. Otherwise a plain text copy of this license needs to be given and packed alongside the distributed product. A complete reference to the base product including email address and web presence must be referenced via the GUI for any GUI program that is a fork of another C-FSL program. If your program has a comprehensive help, manual or info page and is a fork a similar reference to the base product must be given there. It does not apply to quick or short command line help output as long as a more comprehensive help page is also available. Any program under C-FSL which is a fork of another C-FSL program must ship with a reference to the base product. 

7. Contributing to a work under C-FSL means that you will give a group called the 'original authors' a consensus based right to re-license your derived work so that it will be available under both licenses: the C-FSL and the newly applied license. In order to re-license consensus is only required between these original authors. The original authors are the group of people who have initially started to create a work. They shall be mentioned at the beginning of the changelog or the file header of changes. As soon as there is a consensus to do so by all original authors the work may either be re-licensed, published as upstream version without a marker or new people may be accepted and mentioned as 'original authors'. 

8. No work under C-FSL shall be deemed part of an effective measure under anti-circumvention laws like under article 11 of the WIPO copyright treaty adopted on 1996-12-20 or any similar law. By your consent to work under this license you waive any legal power to forbid such circumventions regarding the work under C-FSL or any work combined with it. You must assert that the right to use, modify, generate object code and distribute any software under C-FSL will not be infringed by patent claims or similar law. If you modify a work under C-FSL so that it will knowingly rely on a patent license then it means that you will thereby grant to extend the patent license to any recipient of the work. Every contributor grants by the act of contributing to a work under C-FSL a non-exclusive, worldwide and royalty-free patent license to any prospective contributor or user of the given work applicable to all his 'essential patent claims'. The essential patent claims comprise all claims owned or controlled by the contributor.

9. A work under C-FSL which has another component or plug-in as well as a work under C-FSL which is used itself as a component, plug-in, add-on of another product, any product under C-FSL which is combined or which links against another work requires that the other work will either be put under an open source license as approved by opensource.org or it needs to be put under C-FSL as well. Usage of proprietary libraries and kernel modules pose an exception to this rule. There must be a functionally equivalent open source library for any proprietary library so that a work under C-FSL can run and execute even without any proprietary library. No such restriction applies to kernel modules. The term 'kernel' refers to the core of an operating system. Libraries are separate components which link against the given work or other components. The term 'linking' refers to the relocation of references or addresses when the library is combined with another component in order to make the combined aggregate executable or runnable. Such references are bound to symbols which are part of the common interface between the library and the component which the library is combined with at runtime. Libraries which provide operating system services use a well defined binary interface but do not 'link' against the kernel.

10. This license is either governed by the Laws of Austria or by the laws of the country where the first mentioned original author lives or is a resident. Disputes shall be settled by the nearest proper court given the home town or location of the first original author unless there is a common consensus for another place of court by all original authors. If any of the terms stated in this license were not in accordance with the law of the country that governs this license all other parts of the license shall remain valid.

EOQ
  exit 0;
}

rot=$'\e[1;31m'; drot=$'\e[0;31m'; blau=$'\e[1;34m'; nv=$'\e[0m'; ul=$'\e[4m';
err() { echo -e "${rot}$@${nv}" >&2; }
warn() { echo -e "${drot}$@${nv}" >&2; }
msg() { echo -e "${blau}$@${nv}" >&2; }

ein() { local tok="$1";
  while [ $# -gt 1 ]; do [[ "$tok" = "$2" ]] && return 0; shift; done
  return 1;
}

mkvar() { local rndup=$(roundup $1); local rnddwn=$(rounddown $1);
  [[ -z "$annotdev" ]] && { err "localvars;"; exit; }
  if [[ $rndup = $rnddwn ]]; then
    export ${annotdev}${3/./_}_$rndup=$2$3; >&2
  else
    export ${annotdev}${3/./_}_$rndup=$2$3+$((rndup-$1)); >&2
    export ${annotdev}${3/./_}_$rnddwn=$2$3-$(($1-rnddwn)); >&2
  fi
}

slurpdev() { local annotdev basedev; annotdev="$1"; basedev="$2";
  msg "slurping $basedev"
  while read dev start end blocks id type; do
    dno="${dev#$basedev}";
    if [ "$dev" != "$dno" ]; then 
      mkvar $start ${dev#/dev/} .start
      mkvar $((end+1)) ${dev#/dev/} .end
    fi
  done < <( fdisk -lu -b 512 $basedev | tr '*' ' ' ) 
  export $annotdev="slurped"
}

droploop() {
  local dest loop err=0
  lockfile -1 -r 3 /dev/shm/confinedrv-loops.lock || { 
    err "error: could not lock /dev/shm/confinedrv-loops: will retry"
    lockfile -1 -r 3 /dev/shm/confinedrv-loops.lock || { 
      err "error: lock did not succeed; please execute somewhat later:"
      echo " confinedrv --freeloop $1" >&2;
      return 1;
  };};
  mv /dev/shm/confinedrv-loops /dev/shm/confinedrv-loops.tmp
  while read dest loop; do 
    #echo losetup -d $loop;
    if [[ "$dest" = "$1" ]]; then
      losetup -d $loop || { err=1;
        echo "$dest $loop"; }
    else
      echo "$dest $loop"
    fi
  done </dev/shm/confinedrv-loops.tmp >/dev/shm/confinedrv-loops;
  [[ err -ne 0 ]] && { err "error freeing loop device $1; please execute somewhat later:";
	               echo " confinedrv --freeloop $1" >&2; }
  rm -f /dev/shm/confinedrv-loops.tmp; rm -f /dev/shm/confinedrv-loops.lock
  return $err;
}

verbose=1; readall=false; annotate=true; gapmode=0; mbrmode=1; ret=0;

if [[ $# -le 0 ]]; then
  echo -e "$(basename "$0") --help/--license\n"
fi

getdevno() {
  local attr x usr grp major minor rest
  read attr x usr grp major minor rest < <(ls -l "$1";)
  echo "${major%,}:$minor"
}

# /dev/zero can not be used because it is a character rather than a block device
# zerodev="$(getdevno /dev/zeroblock 2>/dev/null)";
# if [ -z "$zerodev" ]; then && { zerodev=1:5; mknod /dev/zero c 1 5; }

initloops() { local partno=$1

  [[ -n "$rolp" ]] && { err "internal error: ro-loopdev already initialized."; exit 244; }
  [[ verbose -gt 0 ]] && echo $'\e[;33mconfinedrv - visit us on www.elstel.org/qemu\e[0m' >&2;

  mkdir -p /dev/shm/
  #bdev=$(getdevno $org)
  if [[ partno -gt 0 ]]; then
    loop=$(losetup -f) || { err "all loop devices in use (see --loopusage)."; exit 202; }
    losetup $loop $org
  else loop="";
  fi

  rolp=$(losetup -f) || { [[ -n "$loop" ]] && losetup -d $loop; err "all loop devices in use (see --loopusage)."; exit 202; }
  losetup -r $rolp $org
  blockdev --setro $rolp
  chmod gua-w $rolp >/dev/null 2>&1 

  #echo "$dest $loop" >>/dev/shm/confinedrv-loops
  # -> later
}

# device mapper can only control access in chunks of pagesize = 4096 = 2**3*512

PAGE_SIZE=$(getconf PAGE_SIZE)
[[ PAGE_SIZE -eq 0 ]] && { warn "assuming page size of 4096."; PAGE_SIZE=4096; }
[[ PAGE_SIZE/512*512 -ne PAGE_SIZE ]] && { err "page size not divisable by 512; exiting."; exit 222; }
let PGsize=PAGE_SIZE/512
let PGspare=PGsize-1

IssuePartRegion() { # access start end
  local access=$1 start=$2 end=$3 length; let length=end-start
  [[ access -lt -1 ]] && return
  if [[ access -ge 2 ]]; then echo "$start $length linear $loop $start" >&8
  elif [[ access -eq 1 ]]; then echo "$start $length linear $rolp $start" >&8
  elif [[ access -eq 0 ]]; then echo "$start $length zero" >&8
  else echo "$start $length error" >&8
  fi
}

roundup() { echo  $(( ($1+PGspare) / PGsize * PGsize )); }
rounddown() { echo  $(( ($1) / PGsize * PGsize )); }
min() { if [[ $1 -le $2 ]]; then echo $1; else echo $2; fi }
max() { if [[ $1 -ge $2 ]]; then echo $1; else echo $2; fi }
acc2str() { if [[ $1 -ge 2 ]]; then echo "rw"; elif [[ $1 -eq 1 ]]; then echo "r"; elif [[ $1 -eq 0 ]]; then echo "0"; else echo "-"; fi }

NotePartRegion() {
  local access=$1 start=$2 end=$3
  [[ start -le end ]] || return
  [[ prevend -eq start ]] || { err "internal error in NotePartRegion ($prevstart-$prevend, $start-$end+1)"; exit 244; }
  #echo "{$prevacc,$prevstart,$prevend}"
  #echo "<$access,$start,$end>"
  if [[ prevacc -eq access ]]; then let prevend=end+1; return
  elif [[ prevacc -gt access ]]; then
    let start=$(roundup prevend)
    IssuePartRegion $prevacc $prevstart $start
    [[ prevend -lt start && verbose -gt 1 ]] && warn "warning: access right extension $(acc2str $access)->$(acc2str $prevacc) $prevend..$((start-1))"
  else # prevacc -lt access
    let start=$(rounddown prevend)
    IssuePartRegion $prevacc $prevstart $start
    [[ start -lt prevend && verbose -gt 1 ]] && warn "warning: access right extension $(acc2str $prevacc)->$(acc2str $access) $start..$(($prevend-1))"
  fi
  let prevstart=start prevend=end+1 prevacc=access;
}

# global pos extstart extend

NoteExtendedPartition() {
  let extstart=$(rounddown $1) extend=$(roundup $(($2+1)))
}

skip() { local start=$1 extpos dstart;
  [[ pos -le start ]] || { err "trying to skip backwards from $start back to $pos"; exit 244; }
  if [[ extstart -lt extend ]]; then
    let extpos=$(min $(max $pos $extstart) $start);	# extpos ... what we have to skip from $pos until we reach the extended partition header or the $start of the partition $1 before
    let dstart=$(max $(min $start $extend) $extpos);	# 'diminished start position' ... $start of partition inside extended partition or end of the extended partition, but not before $extpos
    # also: let dstart=$(min $start $extend)  + never skip in backward direction: max $extpos (the following command will not condone it)
    NotePartRegion $gapmode $pos $((extpos-1));	# ... skipping before extended partition
    NotePartRegion 1 $extpos $((dstart-1));	# ... extended partition header, intermediate space in ext. part or whole ext. part. if it has no sub-partitions
    NotePartRegion $gapmode $dstart $((start-1));	# ... skip for what comes after the extended partition
    # if we wanted to verify that the previous commands should work under any condition:
    #  $start is before extended partition: pos-extpos = pos-start: $gap,  extpos = start = dstart   =>   extpos-dstart: zerolen,  dstart-start: zerolen
    #  $start is inside extended partition: extpos = max(pos,exstart), dstart = max(pos,start)   =>   pos-extpos: $gap,  extpos-dstart: readable,  dstart-start: zerolen
    #  $start is after extended partition: extpos = max(pos,extstart), dstart = max(pos,extend)   =>  pos-extpos: $gap,  extpos-dstart: readable,  dstart-start: $gap
    #  annot: $start is after extended partition and extended partition unmarked: before ext. part: $gap, rest of ext.part gets readable, then skips with $gap
    #  annot: $start is after extended partition and extended partition already marked: extpos = dstart = end of ext.part: simply skipping with $gap
  else
    NotePartRegion $gapmode $pos $((start-1))
  fi
}

while [[ $# -gt 0 ]]; do
case "$1" in
  --version) echo "confinedrv 1.7.1"; echo;;
  -h|--help) echo -e "confinedrv [--ra] sdx=sda1,2,3,4 sdy=sdb1,2,3,4"
             echo -e "confinedrv [--ra] sdx=sda:r1,2:w3:z4:e7 sdy=sdb:w3"
             echo -e "  --ra ... everything at least readable; default is zeroing out."
	     echo -e "  --mbr err/zero/ro/rw ... master partition table & boot record access rights (std:ro)"
	     echo -e "  --gap err/zero/ro/rw ... access rights for gaps (std:zero)"
	     echo -e "confinedrv -d/-r/--remove sdx sdy ...";
	     echo -e "confinedrv [--noannot] -i/--info sdx sdy ... show annotated drive mapping table";
	     echo -e "confinedrv --loopusage [sdx sdy] ... show all loop devices used for sdx.";
	     echo -e "           -v/--verbose/-q/--quiet: show mapping table / do not show alignement warnings\n"
	     ;;
  -d|-r|--remove) while [ -n "$2" ]; do
		    drv="${2#/dev/mapper/}"
		    dmsetup remove "$drv"
		    droploop "$drv"; [[ $? -ne 0 ]] && let ret++
		    shift
		  done; 
		  exit $ret;;

  -i|--info) while [ -n "$2" ]; do
	       echo "*** $2 ***";
	       while read winstart winlen mode dev devstart; do
		 loopno="${dev#7:}"; 
		 if [[ "$loopno" != "$dev" ]]; then
		   devar="loop_$loopno_"; devident=${!devar};
		   devar="loop_$loopno"; basedev=${!devar};
		   if [[ -z "$devident" ]]; then
		     read loopdev data basedev < <( losetup /dev/loop${loopno}; ); 
		     basedev="${basedev#(}"; basedev="${basedev%)}";
		     [[ -z "$basedev" ]] && basedev=/dev/loop$loopno
		     isro="$(blockdev --getro /dev/loop$loopno)";
		     if [[ $isro -eq 0 ]]; then devident="(${basedev}:rw)"; else devident="(${basedev}:ro)"; fi
		     export $devar="$basedev"; export ${devar}_="$devident";
		   fi
		 else unset devident;
		 fi
		 if $annotate; then
		   annotdev=$(awk '{ gsub(/[^A-Za-z0-9]/,"_"); print; }' <<<"$basedev");
		   [ -z "${!annotdev}" ] && slurpdev $annotdev "$basedev"
		   annotstart=${annotdev}_start_${winstart}; if [[ -n "${!annotstart}" ]]; then annotstart="${!annotstart}"; else 
		     annotstart=${annotdev}_end_${winstart}; if [[ -n "${!annotstart}" ]]; then annotstart="${!annotstart}";
		   else annotstart="$winstart"; fi; fi
		   let winend=winstart+winlen
		   annotend=${annotdev}_end_${winend}; if [[ -n "${!annotend}" ]]; then annotend="${!annotend}"; else annotend="(+)$winlen"; fi
		   if [[ winstart -eq devstart ]]; then echo -e "$annotstart\t$annotend   $mode\t$devident";
		   else echo -e "$annotstart\t$annotend   $mode\t$devident\t$devstart"; fi
		 else
		   if [[ winstart -eq devstart ]]; then echo "$winstart $winlen $mode $devident";
		   else echo "$winstart $winlen $mode $devident $devstart"; fi
		 fi
	       done < <( dmsetup table $2; ) 
	       echo; shift;
	     done;
	     exit 0;;

  --loopusage) if [ -e /dev/shm/ ]; then 
		  if lockfile -1 -r 3 /dev/shm/confinedrv-loops.lock; then didlock=true; else didlock=false; err "error: could not lock /dev/shm/confinedrv-loops"; fi
		  if [[ $# -le 1 ]];
		  then cat /dev/shm/confinedrv-loops
		  else shift; ( IFS="|"; egrep "$*" /dev/shm/confinedrv-loops; )
		  fi
		  $didlock && rm -f /dev/shm/confinedrv-loops.lock 
               else echo "no loop devices in use by confinedrv." >&2; 
	       fi; echo >&2; 
	       exit 0;;

  --freeloop) let ret=0; while [ -n "$2" ]; do droploop "$2" || let ret=1; shift; done; exit $ret;;

  --ra) readall=true; shift; continue; ;;
  --gap) case "$2" in
           zero|z|0) gapmode=0;; error|err|e) gapmode=-1;; read|ro|r|1) gapmode=1;; write|read-write|readwrite|w|rw|2) gapmode=2;;
         esac; shift 2; continue;;
  --mbr) case "$2" in
           zero|z|0) mbrmode=0;; error|err|e) mbrmode=-1;; read|ro|r|1) mbrmode=1;; write|read-write|readwrite|w|rw|2) mbrmode=2;;
         esac; shift 2; continue;;
  -v|--verbose) let verbose++; shift; continue; ;;
  -q|--quiet) let verbose--; shift; continue; ;;
  --noannot) annotate=false; shift; continue; ;;
  --license) license;;
  -*) err "unknown option $1"; echo >&2; exit 201;; 
  *)

[[ $(id -u) -ne 0 ]] && { err "confinedrv must be run as root.";echo; exit 200; }

read dest org <<<"${1/=/ }"
read -a groups <<<"${org//:/ }"
org=${groups[0]%%[0-9]*}; groups[0]=${groups[0]#$org};
[[ -z "${groups[0]}" ]] && { let ng=${#groups[@]}; groups[0]="${groups[ng-1]}"; unset groups[ng-1]; }
for group in "${groups[@]}"; do
  if [[ "${group##[0-9]*}" != "$group" ]]; then
    typ='w';
  else typ="${group:0:1}"; group="${group:1}";
  fi
  ein "$typ" e z r w || { err "access rights for partitions must be one of r/w/z/e."; echo >&2; exit 201; }
  targetvar=parts_$typ[0]; [[ -n "${!targetvar}" ]] && { err "error: already specified: $typ-access rights for $org ($group, ${!targetvar}, ... )."; echo >&2; exit 201; }
  read -a parts_$typ <<<"${group//,/ }"
  # parts=($(sort -g <<<"${parts[@]}";))
  err=false
  for p in ${group//,/ }; do
    [[ -n "${p##[0-9]*}" ]] && { err=true; err "invalid partition number: $p.";echo >&2;  exit 201; }
  done
  $err && exit 201;
done

#echo "org - $org ${parts_e[@]}/${parts_z[@]}/${parts_r[@]}/${parts_w[@]}"
#echo "${groups[@]}"
#exit

[[ -z "$org" ]] && { echo "usage: confinedrv newdevice=olddevice or newdevice=olddevice1,2,3 respectively (see --help)." >&2; echo >&2; exit 201; }
[[ "${org#./}" = "${org#../}" ]] && { [ -e "/dev/$org" ] && org="/dev/$org"; }
[ -e "$org" ] || { err "device $org not found."; echo >&2; exit 203; }

# echo $dest#$org#${#parts[@]}
# echo ${parts[@]}
# echo ----------; exit

let partnum=${#parts_w[@]}+${#parts_r[@]}+${#parts_z[@]}+${#parts_e[@]}

initloops ${#parts_w[@]}

cleanup() {
  sleep 0.3; rm "$drvtable"; [[ -n "$rolp" ]] && losetup -d $rolp; unset rolp; [[ -n "$loop" ]] && losetup -d $loop; unset loop;
}

drvtable="$(mktemp confinedrv-XXXX-XXXX.drvtable)"; trap "cleanup" EXIT
pos=0; prevacc=-2; prevstart=-1; prevend=0; extstart=-1; extend=-2; extwritable=false; found=0; maxdno=0;  #max=0;
{
while read dev start end blocks id type; do
  dno="${dev#$org}";
  if [ "$dev" != "$dno" ]; then 
    [[ dno -gt maxdno ]] && let maxdno=dno
    if [[ pos -eq 0 ]]; then
      NotePartRegion $mbrmode 0 $start
      let pos=start prevend=start
    fi
    #echo "$dev $pos $start" >&2

    if [[ "${type#*Erw}" != "$type" || "${type#*Ext}" != "$type"  ]]; 
      then isext=true; else isext=false; fi

    if $extwritable && [[ extstart -le start && end -lt extend ]];
      then continue; fi

    if ein $dno "${parts_w[@]}"; then
      skip $start
      NotePartRegion 2 $start $end
      let pos=end+1; let found++;
      $isext && { extwritable=true; NoteExtendedPartition $start $end; }

    elif ein $dno "${parts_r[@]}"; then
      skip $start
      NotePartRegion 1 $start $end
      let pos=end+1; let found++;
      $isext && { extwritable=true; NoteExtendedPartition $start $end; }

    elif ein $dno "${parts_z[@]}"; then
      skip $start
      NotePartRegion 0 $start $end
      let pos=end+1; let found++;
      $isext && { extwritable=true; NoteExtendedPartition $start $end; }

    elif ein $dno "${parts_e[@]}"; then
      skip $start
      NotePartRegion -1 $start $end
      let pos=end+1; let found++;
      $isext && { extwritable=true; NoteExtendedPartition $start $end; }

    elif $isext; then
      NoteExtendedPartition $start $end

    elif $readall; then
      skip $start
      NotePartRegion 1 $start $end
      let pos=end+1;

    else
      skip $start
      NotePartRegion 0 $start $end
      let pos=end+1;

    fi
    #[[ max -lt end ]] && let max=end
    #[[ min -gt start ]] && let min=start
  fi
done < <( fdisk -lu -b 512 $org | tr '*' ' ' | sort -g -k 2 -s; ) 
max=$(blockdev --getsz $org)
skip $max
virtualdiskend=$(roundup $prevend)
IssuePartRegion $prevacc $prevstart $virtualdiskend

} 8>"$drvtable"

if [[ maxdno -ge 5 && extpend -lt 0 ]]; then
  err "extended partitions found but no partition called '...Erw' or '...Ext' listed by fdisk -lu";
  echo "you may wish to correct the matching for the name of the exteneded partition in the sources" >&2;
  err "mapping will not function for extended partition"
  echo >&2;
fi

prn_drvtable() {
  while read winstart winend mode dev devstart; do
    if [ "$dev" = "$loop" ]; then dev="(${org#/dev/}:rw)"
    elif [ "$dev" = "$rolp" ]; then dev="(${org#/dev/}:ro)"
    fi
    if [[ winstart -eq devstart ]]; then echo "$winstart $winend $mode $dev";
    else echo "$winstart $winend $mode $dev $devstart"; fi
  done <"$drvtable"
}

if [[ verbose -gt 1 ]]; then
  msg "hdd mapping table:"
  prn_drvtable
  echo
fi


if [[ found -ne partnum ]]; then
  err "overlapping partitions specified (extended partition and partition inside extended partition) or";  
  err "no such partition on disk." # can detect overlapping partitions only in cases where partitions become fully overlapped
  msg "$found out of ${#parts[@]} partitions processed.\n"
  [[ verbose -le 1 ]] && { prn_drvtable; echo >&2; }
  cleanup
  trap '' EXIT
  ret=207
  
else
 if [ -b /dev/mapper/$dest ]; then 
   echo dmsetup reload $dest \<"$drvtable"
   #dmsetup reload $dest <"$drvtable";
   dmsetup remove $dest
   droploop "$dest";
   dmsetup create $dest <"$drvtable";
 else 
   echo dmsetup create $dest \<"$drvtable"
   dmsetup create $dest <"$drvtable";
 fi
 ret=$?
 #if [ $? -eq 0 ]; then rm "$drvtable"; else echo "please remove $drvtable manually!"; fi
 if [ $ret -ne 0 ]; then
   cat $drvtable
   cleanup
 else
   rm "$drvtable"
   lockfile -1 -r 3 /dev/shm/confinedrv-loops.lock || err "error locking /dev/shm/confinedrv-loops."
   [ -n "$loop" ] && echo "$dest $loop" >>/dev/shm/confinedrv-loops
   echo "$dest $rolp" >>/dev/shm/confinedrv-loops
   rm -f /dev/shm/confinedrv-loops.lock
 fi
 trap '' EXIT
 echo
 
fi
[[ ret -gt 0 ]] && exit $ret

;;
esac;
shift;
done
